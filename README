# Algorithm Engineering Exercise 1

## Usage

### Die optimierte Binary bauen 

Rust installieren

```
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

Im Hauptverzeichnis den folgenden Befehl ausführen

```
cargo b --release
```

### Ausführen

Im Hauptverzeichnis den folgenden Befehl ausfüHauptverzeichnis

```
./target/release/algorithm-engineering <graph e.g. stgtregbz.fmi> <source-target-tuples e.g. examples/input_stg>
```

## Note 

- Understand Contraction Hierarchies better. Will we automatically take the shortcut in favor of the normal edge although the path has the same weight in total?
- Vorgängerkante statt Vorgängerknoten speichern
- Von unendlich auf was kleineres -> Knoten in visited array und counter eins hoch. Was ist der Counter vom Visited array 
- Extra array für Vorgänger
- Eine iteration überall eingehenden Kanten für stall on demand
- Eingehenden Kanten mit Node speichern (separates Offset array)
- PHAST = Dijkstra + 1 mal drüber iterieren und relaxieren
- Abbruchkriterium wenn die Distanz größer wird?
- 1 visited liste mit Knoten IDs wo wir rumgepfuscht haben
    - Für jeden Knoten: Distanz von source, distanz von target -> Wenn weniger als bisher gesehen passt es (Stimmt das oder muss es mehr sein - dreiecksungleichung)
- Cache-effizient mit sortierung nach Level
- Up-search s: Stall on demand, von T genauso 
- Abwechselnd wegen Abbruchkriterium -> Nicht bis nach Hamburg nach peek suchen, wenn wir nach Stuttgart Mitte wollen
- Use PQ from up-search to check when to terminate


## Optimierungen

- Abwechseld von Start und Ziel suchen:
    - Wenn eine Node das erste Mal von beiden Seiten aus gesettled wurde, dann wissen wir, dass wir aufhören können und welches das minimale Element aus beiden ist
    - Dafür müssen sich beide Searches eine PQ teilen und ihrer Schritte abwechselnd durchführen
